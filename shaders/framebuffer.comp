#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

// Uniform variables
uniform float f_time;
uniform uint u_time;
uniform uint frame_count;

// Math constants
const float EPSILON = 0.00001;
const float PI = 3.14159265;

// Ray constants
const float TMIN = 0.001;
const float TMAX = 10000.0;
const uint BOUNCE_COUNT = 6;
const uint NUM_SAMPLES = 1;

// Misc
const float ENVIRONMENT_MAP_LE = 1.0;

uvec2 seed_vec;
float fract_time;

// SSBO helper structs

struct Triangle
{
	vec4 v0v1;   // v0.x, v0.y, v0.z, v1.x
	vec4 v1v2;   // v1.y, v1.z, v2.x, v2.y
	vec4 v2norm; // v2.z, n.x, n.y, n.z
	vec4 e1e2;   // e1.x, e1.y, e1.z, e2.x
	vec4 e2matX; // e2.y, e2.z, mat_index, empty
};

struct Sphere
{
	vec4 sphere_data; // o.x, o.y, o.z, radius
	uvec4 mat_index;
};

struct Material
{
	vec4 type_diffuse;  // mat_type, diff.x, diff.y, diff.z
	vec4 specular_spec; // spec.x, spec.y, spec.z, n_spec
	vec4 Le;            // Le.x, Le.y, Le.z, empy
};

// SSBOs

layout(std430, binding = 1) readonly buffer SpheresSSBO
{
	uvec4 num_spheres;
	Sphere spheres[];
} spheres_ssbo;

layout(std430, binding = 2) readonly buffer ModelTrisSSBO
{
	uvec4 num_tris;
	Triangle triangles[];
} model_tris_ssbo;

layout(std430, binding = 3) readonly buffer ModelLightTrisSSBO
{
	uvec4 num_light_tris;
	uint light_tri_indices[];
} light_tris_ssbo;

layout(std430, binding = 4) readonly buffer MaterialsSSBO
{
	uvec4 num_materials;
	Material materials[];
} materials_ssbo;

// Randomness

float hash_to_float(uint hash)
{
	return hash * (1.0 / float(0xffffffffu));
}

vec2 hash_uvec2_to_vec2(uvec2 hash)
{
	return vec2(hash) * (1.0 / float(0xffffffffu));
}

uint pcg(uint v)
{
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
}

uvec2 pcg2d(uvec2 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v>>16u);

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v>>16u);

    return v;
}

// Math

// https://jcgt.org/published/0006/01/01/
void orthonormal_basis(in vec3 n, out vec3 t, out vec3 bt)
{
	float s = sign(n.z);
	float a = -1.0 / (s + n.z);
	float b = n.x * n.y * a;

	t = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);
	bt = vec3(b, s + n.y * n.y * a, -n.y);
}

mat3 construct_tnb(vec3 n)
{
	vec3 t; vec3 bt;
	orthonormal_basis(n, t, bt);
	mat3 res = mat3(t, n, bt);
	return transpose(res);
}

vec3 map_to_unit_sphere(vec2 vec)
{
	// First we map [0,1] to [0,2] and subtract one to map
	// that to [-1, 1], which is the range of cosine.
	float cos_theta = 2.0 * vec.x - 1.0;

	// We can directly map phi to [0, 2PI] from [0, 1] by just
	// multiplying it with 2PI
	float phi = 2.0 * PI * vec.y;

	// sin^2(x) = 1 - cos^2(x)
	// sin(x) = sqrt(1 - cos^2(x))
	float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

	float sin_phi = sin(phi);
	float cos_phi = cos(phi);

	// Just a conversion between spherical and Cartesian coordinates
	return vec3(sin_theta * cos_phi, cos_theta, sin_theta * sin_phi);
}

vec3 map_to_unit_hemisphere_cosine_weighted_criver(vec2 uv, vec3 normal)
{
	vec3 p = map_to_unit_sphere(uv);
	return normalize(p + normal);
}

vec3 sky_color(vec3 dir)
{
	vec3 normalized_dir = normalize(dir);
	float t = 0.5 * (normalized_dir.y + 1.0);

	vec3 start_color = vec3(1.0, 1.0, 1.0);
	vec3 end_color = vec3(0.5, 0.7, 1.0);
	return (1.0 - t) * start_color + t * end_color;
}

// Structs

struct Ray 
{
	vec3 origin;
	vec3 direction;
};

struct LambertianMaterial
{
	vec3 Le; // emitted radiance
	vec3 diffuse; // BRDF
};

struct HitData
{
	float t;
	vec3 normal;
	vec3 point;
	uint material_index;

	bool hit_anything;
};

// Intersection

float intersect_sphere(Ray ray, Sphere sphere)
{
	vec3 oc = ray.origin - sphere.sphere_data.xyz;
	float a = dot(ray.direction, ray.direction);
	float b = 2.0 * dot(oc, ray.direction);
	float c = dot(oc, oc) - sphere.sphere_data.w * sphere.sphere_data.w;
	float discriminant = b * b - 4.0 * a * c;
	if(discriminant >= 0)
	{
		float sqrt_discriminant = sqrt(discriminant);
		if(abs(discriminant) <= EPSILON)
		{
			float t = -b / (2.0 * a);
			if(t >= TMIN && t <= TMAX)
			{
				return t;
			}
		}
		else
		{
			float t1 = (-b + sqrt_discriminant) / (2.0 * a);
			float t2 = (-b - sqrt_discriminant) / (2.0 * a);
			if(t1 > t2)
			{
				float tmp = t1;
				t1 = t2;
				t2 = tmp;
			}

			if(t1 >= TMIN && t1 <= TMAX)
			{
				return t1;
			}
			else if (t2 >= TMIN && t2 <= TMAX)
			{
				return t2;
			}
		}
	}

	return -1.0;
}

HitData intersect(Ray ray)
{
	HitData result;
	result.hit_anything = false;
	result.t = TMAX;

	for(uint i = 0; i < spheres_ssbo.num_spheres.x; i++)
	{
		Sphere current_sphere = spheres_ssbo.spheres[i];
		float current_t = intersect_sphere(ray, current_sphere);
		if(current_t >= TMIN && current_t <= TMAX && current_t < result.t)
		{
			result.t = current_t;
			result.hit_anything = true;
			result.point = ray.origin + ray.direction * current_t;
			result.normal = (result.point - current_sphere.sphere_data.xyz) / current_sphere.sphere_data.w;
			result.material_index = current_sphere.mat_index.x;
		}
	}

	return result;
}

// Estimators

vec3 estimator_path_tracing_lambertian(Ray ray)
{
	vec3 color = vec3(0.0);

	// ( BRDF * dot(Nx, psi) ) / PDF(psi)
	vec3 throughput_term = vec3(1.0);

	// Vignette effect (basically undoing We=1/cos^3(theta) )
	// float32 theta = acosf(-ray.direction.z);
	// throughput_term = throughput_term * powf(cosf(theta), 3);

	for (uint b = 0; b < BOUNCE_COUNT; b++)
	{
		HitData data = intersect(ray);
		if(!data.hit_anything) // ray goes off into infinity
		{
			if (b <= BOUNCE_COUNT)
				color += throughput_term * sky_color(ray.direction) * ENVIRONMENT_MAP_LE;
			break;
		}

		// DEBUG NORMALS
		// color = (data.normal + vec3(1.0)) * 0.5;
		// continue;

		Material mat = materials_ssbo.materials[data.material_index];

		// add the light that the material emits
		if (b <= BOUNCE_COUNT)
			color += throughput_term * mat.Le.xyz;

		// if the material is a diffuse lambertian
		if(mat.type_diffuse.x == 0.0)
		{
			vec3 BRDF = PI * mat.type_diffuse.yzw;

			// update throughput
			// The PI is here because we are sampling w.r.t the pdf
			// p(psi) = cos(theta) / PI       (cosine weighted sampling)
			// This cosine term cancels out with the dot product in
			// the throughput term and all that is left is the BRDF
			throughput_term *= BRDF;

			// pdf(psi) = cos(theta) / PI
			vec2 rand_vec = hash_uvec2_to_vec2(seed_vec);
			seed_vec = pcg2d(seed_vec + uvec2(u_time));
			vec3 dir = map_to_unit_hemisphere_cosine_weighted_criver(rand_vec, data.normal);

			// Intersection point and new ray
			ray = Ray(data.point + EPSILON * data.normal, dir);
		}
		// if the material is ideally reflective 
		else if(mat.type_diffuse.x == 1.0)
		{
			vec3 reflected_dir = reflect(-ray.direction, data.normal);

			// Intersection point and new ray
			vec3 point = data.point;
			ray = Ray(point + EPSILON * data.normal, reflected_dir);

			// If we sample uniformly or with cosine weighted sampling, then
			// we would need to calculate the BRDF every single direction in the
			// hemisphere. If the direction is the reflected direction, then
			// the BRDF is 1, otherwise it is 0. But that is wasteful. Instead,
			// we *only* pick the reflected direction (not the case for glossy or
			// otherwise un-ideal reflective materials) so the pdf is 1, and the
			// BRDF is 1. Because of this, we have an instant solution without
			// having to sample the hemisphere at all. The throughput term is then
			// BRDF*(Nx dot wi) = (Nx dot wi) = cos_theta_x
			throughput_term *= mat.specular_spec.xyz;
		}
		// if the material is a Phong material
		else if(abs(mat.type_diffuse.x - 3.0) <= EPSILON)
		{
			// TODO: fix the diffuse part
			seed_vec = pcg2d(seed_vec + uvec2(u_time));
			vec3 uvec = vec3(seed_vec.x);
			if (all(lessThanEqual(uvec, mat.type_diffuse.yzw * PI)))
			{
				throughput_term *= PI * mat.type_diffuse.yzw;

				// pdf(psi) = cos(theta) / PI
				seed_vec = pcg2d(seed_vec + uvec2(u_time));
				vec3 dir = map_to_unit_hemisphere_cosine_weighted_criver(seed_vec, data.normal);

				ray = Ray(data.point + EPSILON * data.normal, dir);
			}
			else if (all(lessThanEqual(uvec, mat.type_diffuse.yzw * PI + mat.specular_spec.xyz)))
			{
				vec3 Nx = data.normal;
				vec3 x = data.point + EPSILON * data.normal;

				vec3 reflected_dir = normalize(reflect(-ray.direction, Nx));
				mat3 tnb = construct_tnb(reflected_dir);

				float inv = 1.0 / (mat.specular_spec.w + 1.0);

				seed_vec = pcg2d(seed_vec + uvec2(u_time));

				float cos_alpha = pow(seed_vec.x, inv);
				float sin_alpha = sqrt(1.0f - cos_alpha * cos_alpha);
				float phi = 2.0f * PI * seed_vec.y;

				vec3 dir = vec3(sin_alpha * cos(phi), cos_alpha, sin_alpha * sin(phi));

				dir = tnb * dir;
				ray = Ray(x, dir);

				float cos_theta_x = max(0.0, dot(dir, Nx));

				float pdf_theta = ((mat.specular_spec.w + 1.0) / (2.0 * PI)) * pow(cos_alpha, mat.specular_spec.w);
				float theta_term = pow(cos_alpha, mat.specular_spec.w) * ((mat.specular_spec.w + 2.0) / (2.0 * PI)) / pdf_theta;

				throughput_term *= mat.specular_spec.xyz * cos_theta_x * theta_term;
			}
		}
		else
			// UNSUPPORTED MATERIAL!
			return vec3(1.0, 0.0, 0.0);
	}

	return color;
}

vec3 render_function(uvec2 screen_size, ivec2 pixel_coords)
{
	uint width = screen_size.x;
	uint height = screen_size.y;
	float aspect_ratio = float(width) / height;

	float grid_height = 2.0;
	float grid_width = aspect_ratio * grid_height;

	vec3 grid_x = vec3(grid_width, 0.0, 0.0);
	vec3 grid_y = vec3(0.0, -grid_height, 0.0);

	vec3 eye = vec3(0.0, 0.0, 0.0);
	vec3 grid_origin = eye - (grid_x * 0.5) - (grid_y * 0.5);
	grid_origin.z = -2.0;

	int x = pixel_coords.x;
	int y = pixel_coords.y;

	vec3 color = vec3(0.0);
	for(uint s = 0; s < NUM_SAMPLES; s++)
	{
		vec2 offset_to_pixel_center = vec2(0.5, 0.5);

		vec2 uv_offset = hash_uvec2_to_vec2(seed_vec) - offset_to_pixel_center;
		seed_vec = pcg2d(seed_vec + uvec2(u_time));

		float u = (float(x) + uv_offset.x) / float(width);
		float v = (float(y) + uv_offset.y) / float(height);

		vec3 point_on_grid = grid_origin + u * grid_x + v * grid_y;
		vec3 ray_direction = normalize(point_on_grid - eye);

		Ray ray = Ray(eye, ray_direction);

		vec3 calculated_color = estimator_path_tracing_lambertian(ray);

		// INF and NaN check
		if(isnan(calculated_color.x) || 
		   isnan(calculated_color.y) || 
		   isnan(calculated_color.z))
			return vec3(1.0, 0.0, 0.0);

		if(isinf(calculated_color.x) || 
		   isinf(calculated_color.y) || 
		   isinf(calculated_color.z))
			return vec3(1.0, 0.0, 0.0);

		color += calculated_color;
	}

	color /= float(NUM_SAMPLES);
	color.x = sqrt(color.x);
	color.y = sqrt(color.y);
	color.z = sqrt(color.z);

	return color;
}

void main() 
{
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	
	fract_time = fract(f_time);
	seed_vec = pcg2d(uvec2(pixel_coords) + uvec2(u_time));

	uvec2 screen_size = imageSize(screen);
	vec4 last_frame = imageLoad(screen, pixel_coords);

	vec3 color = render_function(screen_size, pixel_coords);

	// weigh current frame according to accumulated past
	// frames and the current frame number
	color = float(frame_count) / float(frame_count + 1) * last_frame.xyz + 1.0 / float(frame_count + 1) * color;

	vec4 final_color = vec4(color, 1.0);
	imageStore(screen, pixel_coords, final_color);
}