#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

vec4 render_function(uvec2 screen_size, ivec2 pixel_coords)
{
	uint width = screen_size.x;
	uint height = screen_size.y;
	float aspect_ratio = float(width) / height;

	float grid_height = 2.0;
	float grid_width = aspect_ratio * grid_height;

	vec3 grid_x = vec3(grid_width, 0.0, 0.0);
	vec3 grid_y = vec3(0.0, -grid_height, 0.0);

	vec3 eye = vec3(0.0, 0.0, 0.0);
	vec3 grid_origin = eye - (grid_x * 0.5) - (grid_y * 0.5);
	grid_origin.z = -2.0;

	int x = pixel_coords.x;
	int y = pixel_coords.y;

	vec2 offset_to_pixel_center = vec2(0.5, 0.5);
	float u = x / float(width);
	float v = y / float(height);

	vec3 point_on_grid = grid_origin + u * grid_x + v * grid_y;
	vec3 ray_direction = normalize(point_on_grid - eye);

	vec3 sphere_origin = vec3(0.0, 0.0, -3.0);
	float sphere_radius = 1.0;

	vec3 o_c = eye - sphere_origin;
	float b = dot(ray_direction, o_c);
	float c = dot(o_c, o_c) - sphere_radius * sphere_radius;
	float intersection_state = b * b - c;
	vec3 intersection = eye + ray_direction * (-b + sqrt(b * b - c));

	if(intersection_state >= 0.0)
	{
		return vec4((normalize(intersection - sphere_origin) + 1.0) / 2.0, 1.0);
	}

	return vec4(0.2, 0.2, 0.2, 1.0);
}

void main() 
{
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	
	uvec2 screen_size = imageSize(screen);
	vec4 color = render_function(screen_size, pixel_coords);

	imageStore(screen, pixel_coords, color);
}