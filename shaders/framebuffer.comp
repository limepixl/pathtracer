#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

// precision lowp float;
// precision lowp int;

// Uniform variables
uniform uvec2 u_frame_data; // seed, frame#

// Math constants
#define EPSILON 		0.000001
#define PI 				3.14159265
#define TWO_PI  		6.28318530
#define HALF_PI 		1.57079632

// Ray constants
#define TMIN            0.001
#define TMAX            10000.0
#define BOUNCE_COUNT    5
#define NUM_SHADOW_RAYS 1

// Misc
#define ENVIRONMENT_MAP_LE 1.0

// SSBO helper structs

// size: 80
struct Triangle
{
	vec4 v0v1;   // v0.x, v0.y, v0.z, v1.x
	vec4 v1v2;   // v1.y, v1.z, v2.x, v2.y
	vec4 v2norm; // v2.z, n.x, n.y, n.z
	vec4 e1e2;   // e1.x, e1.y, e1.z, e2.x
	vec4 e2matX; // e2.y, e2.z, mat_index, empty
};

// size: 32
struct Sphere
{
	vec4 sphere_data; // o.x, o.y, o.z, radius
	uvec4 mat_index;
};

// size: 48
struct Material
{
	vec4 type_diffuse;  // mat_type, diff.x, diff.y, diff.z
	vec4 specular_spec; // spec.x, spec.y, spec.z, n_spec
	vec4 Le;            // Le.x, Le.y, Le.z, empy
};

// size: 32
struct AABB
{
	vec4 data1; // bmin.xyz, bmax.x
	vec4 data2; // bmax.yz
};

// size: 48
struct BVHNode
{
	AABB node_AABB;
	uvec4 data; // left/first_tri, num_tris
};

// SSBOs

layout(std140, binding = 1) readonly buffer SpheresSSBO
{
	Sphere spheres[];
};

layout(std140, binding = 2) readonly buffer ModelTrisSSBO
{
	Triangle triangles[];
};

layout(std430, binding = 3) readonly buffer ModelLightTrisSSBO
{
	uint light_tri_indices[];
};

layout(std140, binding = 4) readonly buffer MaterialsSSBO
{
	Material materials[];
};

layout(std140, binding = 5) readonly buffer BVHSSBO
{
	BVHNode bvh_nodes[];
};

// Randomness
// Great thank you to markjarzynski on Shadertoy
// for their excellent resource on GPU Hash
// functions, created alongside their research.
// https://www.shadertoy.com/view/XlGcRh

uint seed3(uvec3 p) 
{
    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;
}

float hash_to_float(in highp uint hash)
{
	// hash * (1 / MAX_UINT)
	return float(hash) / float(0xfffffff0u);
}

uint pcg(inout uint rng_state)
{
	uint state = rng_state;
	rng_state = rng_state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Make sure to generate a value in (0,1) rather than [0,1]
float rand(inout uint rng_state)
{
	return max(EPSILON, min(1.0 - EPSILON, hash_to_float(pcg(rng_state))));
}

vec2 rand_vec2(inout uint rng_state)
{
	return vec2(rand(rng_state), rand(rng_state));
}

// Math

mat3 construct_tnb(vec3 n)
{
	// Orthonormal basis
	float s = n.z < 0.0 ? -1.0 : 1.0;
	float a = -1.0 / (s + n.z);
	float b = n.x * n.y * a;

	vec3 t = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);
	vec3 bt = vec3(b, s + n.y * n.y * a, -n.y);

	return mat3(t, n, bt);
}

vec3 map_to_unit_sphere(in vec2 vec)
{
	// First we map [0,1] to [0,2] and subtract one to map
	// that to [-1, 1], which is the range of cosine.
	float cos_theta = 2.0 * vec.x - 1.0;

	// We can directly map phi to [0, 2PI] from [0, 1] by just
	// multiplying it with 2PI
	float phi = TWO_PI * vec.y;

	// sin^2(x) = 1 - cos^2(x)
	// sin(x) = sqrt(1 - cos^2(x))
	float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

	// Just a conversion between spherical and Cartesian coordinates
	return vec3(sin_theta * cos(phi), cos_theta, sin_theta * sin(phi));
}

vec3 map_to_unit_hemisphere_cosine_weighted_criver(in vec2 uv, in vec3 normal)
{
	return normalize(map_to_unit_sphere(uv) + normal);
}

vec3 sky_color(vec3 dir)
{
	vec3 normalized_dir = normalize(dir);
	float t = 0.5 * normalized_dir.y + 0.5;

	vec3 start_color = vec3(1.0, 1.0, 1.0);
	vec3 end_color = vec3(0.546, 0.824, 0.925);
	return start_color - t * start_color + t * end_color;
}

// Structs

struct HitData
{
	float t;
	vec3 normal;
	vec3 point;
	uint material_index;
};

// Intersection

float intersect_sphere(vec3 ro, vec3 rd, Sphere sphere)
{
	vec3 oc = ro - sphere.sphere_data.xyz;
	float a = dot(rd, rd);
	float b = 2.0 * dot(oc, rd);
	float c = dot(oc, oc) - sphere.sphere_data.w * sphere.sphere_data.w;
	float discriminant = b * b - 4.0 * a * c;
	if(discriminant >= 0)
	{
		if(abs(discriminant) <= EPSILON)
		{
			float t = -b / (2.0 * a);
			if(t >= TMIN && t <= TMAX)
			{
				return t;
			}
		}
		else
		{
			float sqrt_discriminant = sqrt(discriminant);
			float t1 = (-b + sqrt_discriminant) / (2.0 * a);
			float t2 = (-b - sqrt_discriminant) / (2.0 * a);
			if(t1 > t2)
			{
				float tmp = t1;
				t1 = t2;
				t2 = tmp;
			}

			if(t1 >= TMIN && t1 <= TMAX)
			{
				return t1;
			}
			else if (t2 >= TMIN && t2 <= TMAX)
			{
				return t2;
			}
		}
	}

	return -1.0;
}

// Mollerâ€“Trumbore ray-triangle intersection algorithm
bool intersect_triangle(vec3 ro, vec3 rd, uint tri_index, out HitData data, float tmax)
{
	Triangle tri = triangles[tri_index];
	vec3 edge1 = tri.e1e2.xyz;
	vec3 edge2 = vec3(tri.e1e2.w, tri.e2matX.xy);
	vec3 pvec = cross(rd, edge2);
	float determinant = dot(edge1, pvec);

	// Ray direction parallel to the triangle plane
	if (determinant < EPSILON)
		return false;

	float inv_determinant = 1.0 / determinant;
	vec3 tvec = ro - tri.v0v1.xyz;
	float u = dot(tvec, pvec) * inv_determinant;
	if ((u < 0.0) || (u > 1.0))
		return false;

	vec3 qvec = cross(tvec, edge1);
	float v = inv_determinant * dot(rd, qvec);
	if ((v < 0.0) || (u + v > 1.0))
		return false;

	// Computing t
	float t = inv_determinant * dot(edge2, qvec);
	if (t > TMIN && t < tmax)
	{
		data.t = t;
		data.point = ro + rd * t;
		data.normal = tri.v2norm.yzw;
		data.material_index = uint(tri.e2matX.z);
		// data.object_type = ObjectType::TRIANGLE;
		return true;
	}

	return false;
}

// Slab method
// https://tavianator.com/2011/ray_box.html
bool intersect_aabb(vec3 ro, vec3 rd, in vec3 bmin, in vec3 bmax, in float t)
{
	vec3 inv_dir = 1.0 / rd;
	float tx1 = bmin.x * inv_dir.x - ro.x * inv_dir.x;
	float tx2 = bmax.x * inv_dir.x - ro.x * inv_dir.x;
	float tmin = min(tx1, tx2);
	float tmax = max(tx1, tx2);

	float ty1 = bmin.y * inv_dir.y - ro.y * inv_dir.y;
	float ty2 = bmax.y * inv_dir.y - ro.y * inv_dir.y;

	tmin = max(tmin, min(ty1, ty2));
	tmax = min(tmax, max(ty1, ty2));

	float tz1 = bmin.z * inv_dir.z - ro.z * inv_dir.z;
	float tz2 = bmax.z * inv_dir.z - ro.z * inv_dir.z;

	tmin = max(tmin, min(tz1, tz2));
	tmax = min(tmax, max(tz1, tz2));

	return tmax >= max(0.0, tmin) && tmin < t;
}

float squared_dist(in AABB aabb, in vec3 point)
{
	vec3 p = aabb.data1.xyz - point;
	vec3 q = point - vec3(aabb.data1.w, aabb.data2.xy);
	vec3 d = max(max(p, 0.0), q);
	return dot(d, d);
}

bool intersect_bvh_stack(vec3 ro, vec3 rd, inout HitData data)
{
	bool hit_anything = false;

	int stack_top = 0;
	uint stack[12];
	stack[0] = 0;

	while (stack_top + 1 > 0)
	{
		BVHNode node = bvh_nodes[stack[stack_top]];
		stack_top--;
		uint node_left = node.data[0];
		uint num_node_tris = node.data[1];

		// Check if ray intersects root node
		vec3 bmin = node.node_AABB.data1.xyz;
		vec3 bmax = vec3(node.node_AABB.data1.w, node.node_AABB.data2.xy);
		if(intersect_aabb(ro, rd, bmin, bmax, data.t))
		{
			if(num_node_tris == 0)
			{
				stack_top++;
				stack[stack_top] = node_left;
				stack_top++;
				stack[stack_top] = node_left + 1;
			}
			else
			{
				// If leaf node, test against triangles of node
				for (uint i = 0; i < num_node_tris; i++)
				{
					HitData current_data;
					if (intersect_triangle(ro, rd, node_left + i, current_data, data.t) && current_data.t < data.t)
					{
						// Found closer hit, store it.
						// current_data.object_index = node.first_tri + i;

						hit_anything = true;
						data = current_data;
					}
				}
			}
		}
	}

	return hit_anything;
}

bool intersect(vec3 ro, vec3 rd, out HitData result)
{
	bool hit_anything = false;
	result.t = TMAX;

	for(uint i = 0; i < spheres.length(); i++)
	{
		Sphere current_sphere = spheres[i];
		float current_t = intersect_sphere(ro, rd, current_sphere);
		if(current_t >= TMIN && current_t <= TMAX && current_t < result.t)
		{
			hit_anything = true;
			result.t = current_t;
			result.point = ro + rd * current_t;
			result.normal = (result.point - current_sphere.sphere_data.xyz) / current_sphere.sphere_data.w;
			result.material_index = current_sphere.mat_index.x;
		}
	}

	return hit_anything || intersect_bvh_stack(ro, rd, result);
}

// Estimators

vec3 estimator_path_tracing_naive(inout vec3 ro, inout vec3 rd, in uint rng_state)
{
	vec3 color = vec3(0.0);

	// ( BRDF * dot(Nx, psi) ) / PDF(psi)
	vec3 throughput_term = vec3(1.0);

	// Vignette effect (basically undoing We=1/cos^3(theta) )
	// float theta = acos(-rd.z);
	// throughput_term = throughput_term * pow(cos(theta), 3);

	for (uint b = 0; b < BOUNCE_COUNT; b++)
	{
		HitData data;
		bool hit_anything = intersect(ro, rd, data);
		if(!hit_anything) // ray goes off into infinity
		{
			if (b <= BOUNCE_COUNT)
				color += throughput_term * sky_color(rd) * ENVIRONMENT_MAP_LE;
			return color;
		}

		Material mat = materials[data.material_index];

		// add the light that the material emits
		if (b <= BOUNCE_COUNT)
			color += throughput_term * mat.Le.xyz;

		vec3 pi_diffuse = PI * mat.type_diffuse.yzw;

		// if the material is a diffuse lambertian
		if(mat.type_diffuse.x <= EPSILON)
		{
			// update throughput
			// The PI is here because we are sampling w.r.t the pdf
			// p(psi) = cos(theta) / PI       (cosine weighted sampling)
			// This cosine term cancels out with the dot product in
			// the throughput term and all that is left is the BRDF
			throughput_term *= pi_diffuse;

			// Intersection point and new ray
			ro = data.point + EPSILON * data.normal;
			// pdf(psi) = cos(theta) / PI
			rd = map_to_unit_hemisphere_cosine_weighted_criver(rand_vec2(rng_state), data.normal);
		}
		// if the material is ideally reflective 
		else if(abs(mat.type_diffuse.x - 1.0) <= EPSILON)
		{
			// Intersection point and new ray
			ro = data.point + EPSILON * data.normal;
			rd = reflect(rd, data.normal);

			// If we sample uniformly or with cosine weighted sampling, then
			// we would need to calculate the BRDF every single direction in the
			// hemisphere. If the direction is the reflected direction, then
			// the BRDF is 1, otherwise it is 0. But that is wasteful. Instead,
			// we *only* pick the reflected direction (not the case for glossy or
			// otherwise un-ideal reflective materials) so the pdf is 1, and the
			// BRDF is 1. Because of this, we have an instant solution without
			// having to sample the hemisphere at all. The throughput term is then
			// BRDF*(Nx dot wi) = (Nx dot wi) = cos_theta_x
			throughput_term *= mat.specular_spec.xyz;
		}
		// if the material is a Phong material
		else if(abs(mat.type_diffuse.x - 3.0) <= EPSILON)
		{
			vec3 uvec = vec3(rand(rng_state));

			vec3 specular = mat.specular_spec.xyz;
			float spec = mat.specular_spec.w;

			if(all(lessThanEqual(uvec, pi_diffuse)))
			{
				throughput_term *= pi_diffuse;

				ro = data.point + EPSILON * data.normal;
				// pdf(psi) = cos(theta) / PI
				rd = map_to_unit_hemisphere_cosine_weighted_criver(rand_vec2(rng_state), data.normal);
			}
			else if(all(lessThanEqual(uvec, pi_diffuse + specular)))
			{
				vec3 reflected_dir = normalize(reflect(rd, data.normal));

				mat3 tnb = construct_tnb(reflected_dir);

				float inv = 1.0 / (spec + 1.0);

				vec2 rand_vec = rand_vec2(rng_state);

				float cos_alpha = pow(rand_vec.x, inv);
				float sin_alpha = sqrt(1.0 - cos_alpha * cos_alpha);
				float phi = TWO_PI * rand_vec.y;

				rd = vec3(sin_alpha * cos(phi), cos_alpha, sin_alpha * sin(phi));

				rd = normalize(tnb * rd);
				ro = data.point + EPSILON * data.normal;

				float cos_theta_x = max(0.0, dot(rd, data.normal));

				float pow_cosalpha_spec = pow(cos_alpha, spec);
				// float pdf_theta = ((spec + 1.0) / (2.0 * PI)) * pow(cos_alpha, spec);
				float pdf_theta = spec * HALF_PI * pow_cosalpha_spec + HALF_PI * pow_cosalpha_spec;
				// float theta_term = pow(cos_alpha, spec) * ((spec + 2.0) / (2.0 * PI)) / pdf_theta;
				float theta_term = pow_cosalpha_spec * spec * HALF_PI / pdf_theta + PI * pow_cosalpha_spec / pdf_theta;

				throughput_term *= specular * cos_theta_x * theta_term;
			}
		}
	}

	return color;
}

float area(Triangle tri)
{
	vec3 edge2 = vec3(tri.e1e2.w, tri.e2matX.xy);
	return sqrt(dot(tri.e1e2.xyz, tri.e1e2.xyz) * dot(edge2, edge2)) * 0.5;
}

vec3 map_to_triangle(vec2 vec, Triangle tri)
{
	float u = vec.x;
	float v = vec.y;

	if (u + v > 1.0)
	{
		// The generated point is outside triangle but
		// within the parallelogram defined by the 2 edges
		// of the triangle (v1-v0 and v2-v0)
		u = 1.0 - u;
		v = 1.0 - v;
	}

	vec3 p = u * tri.e1e2.xyz + v * vec3(tri.e1e2.w, tri.e2matX.xy);;
	return p + tri.v0v1.xyz;
}

vec3 estimator_path_tracing_nee(inout vec3 ro, inout vec3 rd, in uint rng_state)
{
	vec3 color = vec3(0.0);
	vec3 throughput_term = vec3(1.0);

	bool old_mat_changed = false;
	Material old_mat;

	for (uint bounce = 0; bounce < BOUNCE_COUNT; bounce++)
	{
		HitData data;
		bool hit_anything = intersect(ro, rd, data);
		if (!hit_anything)
		{
			// No intersection with scene, add env map contribution
			color += throughput_term * sky_color(rd) * ENVIRONMENT_MAP_LE;
			break;
		}

		Material mat = materials[data.material_index];
		vec3 BRDF = mat.type_diffuse.yzw;

		// (x->y dot Nx)
		float cos_theta = dot(data.normal, rd);

		// add light that is emitted from surface (but stop right afterwards)
		if (bounce <= BOUNCE_COUNT && mat.Le.x >= 0.1)
		{
			// TODO: only add if the ray was added by a single lonely bounce from
			// the mirror instead of just the last bounce being the mirror?
			bool last_bounce_reflected = (old_mat_changed && old_mat.type_diffuse.x == 3.0 && 
										  all(equal(old_mat.type_diffuse.yzw, vec3(0.0))) && 
										  any(greaterThan(old_mat.specular_spec, vec4(0.01))));
			if (bounce == 0 || last_bounce_reflected)
				return mat.Le.xyz;

			return color;
		}
		// If there is at least 1 light source in the scene and the material
		// of the surface we hit is diffuse, we can use NEE.
		else if (light_tri_indices.length() > 0 && 
		        (mat.type_diffuse.x == 0.0 || (mat.type_diffuse.x == 3.0 && mat.specular_spec.xyz == vec3(0.0))))
		{
			// sample light sources for direct illumination
			vec3 direct_illumination = vec3(0.0);
			// for (uint shadow_ray_index = 0; shadow_ray_index < NUM_SHADOW_RAYS; shadow_ray_index++)
			{
				// pick a light source
				float pdf_pick_light = 1.0 / float(light_tri_indices.length());

				int picked_light_source = int((mod(rand(rng_state), light_tri_indices.length())));
				Triangle light_source = triangles[light_tri_indices[picked_light_source]];

				Material light_source_mat = materials[uint(light_source.e2matX.z)];

				// TODO: implement area functions for all primitives
				float light_area = area(light_source);
				float pdf_pick_point_on_light = 1.0 / light_area;
				vec3 y = map_to_triangle(rand_vec2(rng_state), light_source);

				// PDF in terms of area, for picking point on light source k
				float pdf_light_area = pdf_pick_light * pdf_pick_point_on_light;

				// Just for clarity
				vec3 x = data.point + EPSILON * data.normal;

				// Send out a shadow ray in direction x->y
				vec3 dist_vec = y - x;

				vec3 shadow_ro = x;
				vec3 shadow_rd = normalize(dist_vec);

				// Check if ray hits anything before hitting the light source
				HitData shadow_data;
				bool shadow_hit_anything = intersect(shadow_ro, shadow_rd, shadow_data);
				// if (!shadow_hit_anything)
				// {
				// 	// It shouldn't be possible to send a ray towards the light
				// 	// source and not hit anything in the scene, even the light
				// 	// printf("ERROR: Shadow ray didn't hit anything!\n");
				// 	// break;

				// 	// return CreateVec3f(5.0f, 0.0f, 5.0f);
				// }

				// Visibility check means we have a clear line of sight!
				if (shadow_hit_anything && y == shadow_data.point)
				{
					float squared_dist = dot(dist_vec, dist_vec);

					// We want to only add light contribution from lights within
					// the hemisphere solid angle above X, and not from lights behind it.
					float cos_theta_x = max(0.0, dot(data.normal, shadow_rd));

					// We can sample the light from both sides, it doesn't have to
					// be a one-sided light source.
					float cos_theta_y = max(0.0, dot(shadow_data.normal, -shadow_rd));

					float G = cos_theta_x * cos_theta_y / squared_dist;

					direct_illumination += light_source_mat.Le.xyz * BRDF * G / pdf_light_area;
					// if (direct_illumination.x != direct_illumination.x || direct_illumination.y != direct_illumination.y || direct_illumination.z != direct_illumination.z)
					// {
					// 	// NaN
					// 	return vec3(1.0, 0.0, 0.0);
					// }
				}
			}
			// direct_illumination /= float(NUM_SHADOW_RAYS);

			// Because we are calculating for a non-emissive point, we can safely
			// add the direct illumination to this point.
			color += throughput_term * direct_illumination;

			// Update the throughput term
			float pdf_cos_weighted_hemisphere = cos_theta / PI;
			throughput_term *= BRDF * cos_theta / pdf_cos_weighted_hemisphere;
			// throughput_term *= PI * BRDF;

			ro = data.point + EPSILON * data.normal;
			rd =  map_to_unit_hemisphere_cosine_weighted_criver(rand_vec2(rng_state), data.normal);
		}
		else if (abs(mat.type_diffuse.x - 1.0) < EPSILON)
		{
			vec3 reflected_dir = reflect(rd, data.normal);

			// Intersection point and new ray
			// vec3 point = data.point;
			// ray = Ray(point + EPSILON * data.normal, reflected_dir);
			ro = data.point + EPSILON * data.normal;
			rd = reflected_dir;

			// If we sample uniformly or with cosine weighted sampling, then
			// we would need to calculate the BRDF every single direction in the
			// hemisphere. If the direction is the reflected direction, then
			// the BRDF is 1, otherwise it is 0. But that is wasteful. Instead,
			// we *only* pick the reflected direction (not the case for glossy or
			// otherwise un-ideal reflective materials) so the pdf is 1, and the
			// BRDF is 1. Because of this, we have an instant solution without
			// having to sample the hemisphere at all. The throughput term is then
			// BRDF*(Nx dot wi) = (Nx dot wi) = cos_theta_x
			// throughput_term *= Abs(cos_theta);
		}
		else if (abs(mat.type_diffuse.x - 3.0) < EPSILON)
		{
			// TODO: support the diffuse part

			vec3 Nx = data.normal;

			vec3 reflected_dir = normalize(reflect(rd, Nx));
			mat3 tnb = construct_tnb(reflected_dir);

			float spec = mat.specular_spec.w;
			float inv = 1.0 / (spec + 1.0);

			vec2 random_vec2f = rand_vec2(rng_state);

			float cos_alpha = pow(random_vec2f.x, inv);
			float sin_alpha = sqrt(1.0f - cos_alpha * cos_alpha);
			float phi = TWO_PI * random_vec2f.y;

			vec3 dir = vec3(sin_alpha * cos(phi), cos_alpha, sin_alpha * sin(phi));

			dir = tnb * dir;
			ro = data.point + EPSILON * data.normal;
			rd = dir;

			float cos_theta_x = max(0.0, dot(dir, Nx));

			float pdf_theta = ((spec + 1.0) / (2.0 * PI)) * pow(cos_alpha, spec);
			float theta_term = pow(cos_alpha, spec) * ((spec + 2.0) / (2.0 * PI)) / pdf_theta;
			throughput_term *= mat.specular_spec.xyz * cos_theta_x * theta_term;
		}

		old_mat = mat;
		old_mat_changed = true;
	}

	return color;
}

vec3 render_function(uvec2 screen_size, ivec2 pixel_coords, in uint rng_state)
{
	uint width = screen_size.x;
	uint height = screen_size.y;
	float aspect_ratio = float(width) / height;

	float grid_height = 2.0;
	float grid_width = aspect_ratio * grid_height;

	vec3 grid_x = vec3(grid_width, 0.0, 0.0);
	vec3 grid_y = vec3(0.0, grid_height, 0.0);

	vec3 eye = vec3(0.0, 0.0, 0.0);
	vec3 grid_origin = eye - (grid_x * 0.5) - (grid_y * 0.5);
	grid_origin.z = -2.0;

	int x = pixel_coords.x;
	int y = pixel_coords.y;

	vec2 offset_to_pixel_center = vec2(0.5, 0.5);
	vec2 uv_offset = rand_vec2(rng_state) - offset_to_pixel_center;

	float u = (float(x) + uv_offset.x) / float(width);
	float v = (float(y) + uv_offset.y) / float(height);

	vec3 point_on_grid = grid_origin + u * grid_x + v * grid_y;
	vec3 ray_direction = normalize(point_on_grid - eye);

	return estimator_path_tracing_naive(eye, ray_direction, rng_state);
}

void main() 
{
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	uvec2 screen_size = imageSize(screen);
	vec4 last_frame = imageLoad(screen, pixel_coords);
	
	uint rng_state = seed3(uvec3(pixel_coords, u_frame_data.x));

	vec3 color = render_function(screen_size, pixel_coords, rng_state);

	memoryBarrierImage();
	barrier();

	// weigh current frame according to accumulated past
	// frames and the current frame number
	color = float(u_frame_data.y) / float(u_frame_data.y + 1) * last_frame.xyz + 1.0 / float(u_frame_data.y + 1) * color;

	imageStore(screen, pixel_coords, vec4(color, 1.0));

	memoryBarrierImage();
	barrier();
}