#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

// Uniform variables
uniform uint u_seed;
uniform uint frame_count;

// Math constants
const float EPSILON = 0.000001;
const float PI = 3.14159265;
const float TWO_PI = 6.28318530;
const float HALF_PI = 1.57079632;

// Ray constants
const float TMIN = 0.001;
const float TMAX = 10000.0;
const uint BOUNCE_COUNT = 5;

// Misc
const float ENVIRONMENT_MAP_LE = 1.0;

uvec2 seed_vec = uvec2(0);
uint rng_state = 0;

// SSBO helper structs

struct Triangle
{
	vec4 v0v1;   // v0.x, v0.y, v0.z, v1.x
	vec4 v1v2;   // v1.y, v1.z, v2.x, v2.y
	vec4 v2norm; // v2.z, n.x, n.y, n.z
	vec4 e1e2;   // e1.x, e1.y, e1.z, e2.x
	vec4 e2matX; // e2.y, e2.z, mat_index, empty
};

struct Sphere
{
	vec4 sphere_data; // o.x, o.y, o.z, radius
	uvec4 mat_index;
};

struct Material
{
	vec4 type_diffuse;  // mat_type, diff.x, diff.y, diff.z
	vec4 specular_spec; // spec.x, spec.y, spec.z, n_spec
	vec4 Le;            // Le.x, Le.y, Le.z, empy
};

struct AABB
{
	vec4 data1; // bmin.xyz, bmax.x
	vec4 data2; // bmax.yz
};

struct BVHNode
{
	AABB node_AABB;
	uvec4 data; // left/first_tri, num_tris
};

// SSBOs

layout(std430, binding = 1) readonly buffer SpheresSSBO
{
	Sphere spheres[];
} spheres_ssbo;

layout(std430, binding = 2) readonly buffer ModelTrisSSBO
{
	Triangle triangles[];
} model_tris_ssbo;

layout(std430, binding = 3) readonly buffer ModelLightTrisSSBO
{
	uint light_tri_indices[];
} light_tris_ssbo;

layout(std430, binding = 4) readonly buffer MaterialsSSBO
{
	Material materials[];
} materials_ssbo;

layout(std430, binding = 5) readonly buffer BVHSSBO
{
	BVHNode bvh_nodes[];
} bvh_ssbo;

// Randomness
// Great thank you to markjarzynski on Shadertoy
// for their excellent resource on GPU Hash
// functions, created alongside their research.
// https://www.shadertoy.com/view/XlGcRh

uint seed3(uvec3 p) 
{
    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;
}

float hash_to_float(uint hash)
{
	// hash * 1 / MAX_UINT
	// TODO: find out why result is sometimes bigger than 1
	return min(1.0, float(hash) * uintBitsToFloat(0x2f800004u));
}

uint pcg()
{
	uint state = rng_state;
	rng_state = rng_state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float rand()
{
	return hash_to_float(pcg());
}

vec2 rand_vec2()
{
	return vec2(rand(), rand());
}

// Math

mat3 construct_tnb(vec3 n)
{
	// Orthonormal basis
	float s = n.z < 0.0 ? -1.0 : 1.0;
	float a = -1.0 / (s + n.z);
	float b = n.x * n.y * a;

	vec3 t = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);
	vec3 bt = vec3(b, s + n.y * n.y * a, -n.y);

	return mat3(t, n, bt);
}

vec3 map_to_unit_sphere(in vec2 vec)
{
	// First we map [0,1] to [0,2] and subtract one to map
	// that to [-1, 1], which is the range of cosine.
	float cos_theta = 2.0 * vec.x - 1.0;

	// We can directly map phi to [0, 2PI] from [0, 1] by just
	// multiplying it with 2PI
	float phi = TWO_PI * vec.y;

	// sin^2(x) = 1 - cos^2(x)
	// sin(x) = sqrt(1 - cos^2(x))
	float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

	// Just a conversion between spherical and Cartesian coordinates
	return vec3(sin_theta * cos(phi), cos_theta, sin_theta * sin(phi));
}

vec3 map_to_unit_hemisphere_cosine_weighted_criver(in vec2 uv, in vec3 normal)
{
	return normalize(map_to_unit_sphere(uv) + normal);
}

vec3 sky_color(vec3 dir)
{
	vec3 normalized_dir = normalize(dir);
	float t = 0.5 * normalized_dir.y + 0.5;

	vec3 start_color = vec3(1.0, 1.0, 1.0);
	vec3 end_color = vec3(0.546, 0.824, 0.925);
	return start_color - t * start_color + t * end_color;
}

// Structs

struct Ray 
{
	vec3 origin;
	vec3 direction;
	vec3 inv_dir;
};

struct LambertianMaterial
{
	vec3 Le; // emitted radiance
	vec3 diffuse; // BRDF
};

struct HitData
{
	float t;
	vec3 normal;
	vec3 point;
	uint material_index;

	bool hit_anything;
};

// Intersection

float intersect_sphere(Ray ray, Sphere sphere)
{
	vec3 oc = ray.origin - sphere.sphere_data.xyz;
	float a = dot(ray.direction, ray.direction);
	float b = 2.0 * dot(oc, ray.direction);
	float c = dot(oc, oc) - sphere.sphere_data.w * sphere.sphere_data.w;
	float discriminant = b * b - 4.0 * a * c;
	if(discriminant >= 0)
	{
		if(abs(discriminant) <= EPSILON)
		{
			float t = -b / (2.0 * a);
			if(t >= TMIN && t <= TMAX)
			{
				return t;
			}
		}
		else
		{
			float sqrt_discriminant = sqrt(discriminant);
			float t1 = (-b + sqrt_discriminant) / (2.0 * a);
			float t2 = (-b - sqrt_discriminant) / (2.0 * a);
			if(t1 > t2)
			{
				float tmp = t1;
				t1 = t2;
				t2 = tmp;
			}

			if(t1 >= TMIN && t1 <= TMAX)
			{
				return t1;
			}
			else if (t2 >= TMIN && t2 <= TMAX)
			{
				return t2;
			}
		}
	}

	return -1.0;
}

// Mollerâ€“Trumbore ray-triangle intersection algorithm
bool intersect_triangle(in Ray ray, in uint tri_index, out HitData data, in float tmax)
{
	Triangle tri = model_tris_ssbo.triangles[tri_index];
	vec3 edge1 = tri.e1e2.xyz;
	vec3 edge2 = vec3(tri.e1e2.w, tri.e2matX.xy);
	vec3 pvec = cross(ray.direction, edge2);
	float determinant = dot(edge1, pvec);

	// Ray direction parallel to the triangle plane
	if (determinant < EPSILON)
		return false;

	float inv_determinant = 1.0 / determinant;
	vec3 tvec = ray.origin - tri.v0v1.xyz;
	float u = dot(tvec, pvec) * inv_determinant;
	if ((u < 0.0) || (u > 1.0))
		return false;

	vec3 qvec = cross(tvec, edge1);
	float v = inv_determinant * dot(ray.direction, qvec);
	if ((v < 0.0) || (u + v > 1.0))
		return false;

	// Computing t
	float t = inv_determinant * dot(edge2, qvec);
	if (t > TMIN && t < tmax)
	{
		data.t = t;
		data.point = ray.origin + ray.direction * t;
		data.normal = tri.v2norm.yzw;
		data.material_index = uint(tri.e2matX.z);
		// data.object_type = ObjectType::TRIANGLE;
		return true;
	}

	return false;
}

// Slab method
// https://tavianator.com/2011/ray_box.html
bool AABBIntersect(in Ray ray, in AABB aabb, in float t)
{
	vec3 bmin = aabb.data1.xyz;
	vec3 bmax = vec3(aabb.data1.w, aabb.data2.xy);

	float tx1 = bmin.x * ray.inv_dir.x - ray.origin.x * ray.inv_dir.x;
	float tx2 = bmax.x * ray.inv_dir.x - ray.origin.x * ray.inv_dir.x;
	float tmin = min(tx1, tx2);
	float tmax = max(tx1, tx2);

	float ty1 = bmin.y * ray.inv_dir.y - ray.origin.y * ray.inv_dir.y;
	float ty2 = bmax.y * ray.inv_dir.y - ray.origin.y * ray.inv_dir.y;

	tmin = max(tmin, min(ty1, ty2));
	tmax = min(tmax, max(ty1, ty2));

	float tz1 = bmin.z * ray.inv_dir.z - ray.origin.z * ray.inv_dir.z;
	float tz2 = bmax.z * ray.inv_dir.z - ray.origin.z * ray.inv_dir.z;

	tmin = max(tmin, min(tz1, tz2));
	tmax = min(tmax, max(tz1, tz2));

	return tmax >= max(0.0, tmin) && tmin < t;
}

float squared_dist(in AABB aabb, in vec3 point)
{
	vec3 p = aabb.data1.xyz - point;
	vec3 q = point - vec3(aabb.data1.w, aabb.data2.xy);
	vec3 d = max(max(p, 0.0), q);
	return dot(d, d);
}

bool intersect_bvh_stack(in Ray ray, inout HitData data)
{
	bool hit_anything = false;

	int stack_top = 0;
	uint stack[1000];
	stack[0] = 0;

	while (stack_top + 1 > 0)
	{
		BVHNode node = bvh_ssbo.bvh_nodes[stack[stack_top]];
		stack_top--;
		uint node_left = node.data[0];
		uint num_node_tris = node.data[1];

		// Check if ray intersects root node
		if (AABBIntersect(ray, node.node_AABB, data.t))
		{
			if (num_node_tris == 0)
			{
				float dist1 = squared_dist(bvh_ssbo.bvh_nodes[node_left].node_AABB, ray.origin);
				float dist2 = squared_dist(bvh_ssbo.bvh_nodes[node_left + 1].node_AABB, ray.origin);

				float squared_tmax = data.t * data.t;

				// TODO: simplify if statements here
				if (dist1 <= dist2)
				{
					if (dist2 < squared_tmax)
					{
						stack_top++;
						stack[stack_top] = node_left + 1;
					}

					if (dist1 < squared_tmax)
					{
						stack_top++;
						stack[stack_top] = node_left;
					}
				}
				else
				{
					if (dist1 < squared_tmax)
					{
						stack_top++;
						stack[stack_top] = node_left;
					}

					if (dist2 < squared_tmax)
					{
						stack_top++;
						stack[stack_top] = node_left + 1;
					}
				}
			}
			else
			{
				// If leaf node, test against triangles of node
				for (uint i = 0; i < num_node_tris; i++)
				{
					HitData current_data;
					bool intersect = intersect_triangle(ray, node_left + i, current_data, data.t);
					if (intersect && current_data.t < data.t)
					{
						// Found closer hit, store it.
						// tmax = current_data.t;
						// current_data.object_index = node.first_tri + i;

						hit_anything = true;
						data = current_data;
					}
				}
			}
		}
	}

	return hit_anything;
}

HitData intersect(Ray ray)
{
	HitData result;
	result.hit_anything = false;
	result.t = TMAX;

	for(uint i = 0; i < spheres_ssbo.spheres.length(); i++)
	{
		Sphere current_sphere = spheres_ssbo.spheres[i];
		float current_t = intersect_sphere(ray, current_sphere);
		if(current_t >= TMIN && current_t <= TMAX && current_t < result.t)
		{
			result.t = current_t;
			result.hit_anything = true;
			result.point = ray.origin + ray.direction * current_t;
			result.normal = (result.point - current_sphere.sphere_data.xyz) / current_sphere.sphere_data.w;
			result.material_index = current_sphere.mat_index.x;
		}
	}

	result.hit_anything = result.hit_anything || intersect_bvh_stack(ray, result);

	return result;
}

// Estimators

vec3 estimator_path_tracing_lambertian(Ray ray)
{
	vec3 color = vec3(0.0);

	// ( BRDF * dot(Nx, psi) ) / PDF(psi)
	vec3 throughput_term = vec3(1.0);

	// Vignette effect (basically undoing We=1/cos^3(theta) )
	// float theta = acos(-ray.direction.z);
	// throughput_term = throughput_term * pow(cos(theta), 3);

	for (uint b = 0; b < BOUNCE_COUNT; b++)
	{
		HitData data = intersect(ray);
		if(!data.hit_anything) // ray goes off into infinity
		{
			if (b <= BOUNCE_COUNT)
				color += throughput_term * sky_color(ray.direction) * ENVIRONMENT_MAP_LE;
			break;
		}

		// DEBUG NORMALS
		// color = (data.normal + vec3(1.0)) * 0.5;
		// continue;

		Material mat = materials_ssbo.materials[data.material_index];

		// add the light that the material emits
		if (b <= BOUNCE_COUNT)
			color += throughput_term * mat.Le.xyz;

		// if the material is a diffuse lambertian
		if(mat.type_diffuse.x <= EPSILON)
		{
			// update throughput
			// The PI is here because we are sampling w.r.t the pdf
			// p(psi) = cos(theta) / PI       (cosine weighted sampling)
			// This cosine term cancels out with the dot product in
			// the throughput term and all that is left is the BRDF
			throughput_term *= PI * mat.type_diffuse.yzw;

			// pdf(psi) = cos(theta) / PI
			vec2 rand_vec = rand_vec2();
			vec3 dir = map_to_unit_hemisphere_cosine_weighted_criver(rand_vec, data.normal);

			// Intersection point and new ray
			ray = Ray(data.point + EPSILON * data.normal, dir, 1.0 / dir);
		}
		// if the material is ideally reflective 
		else if(abs(mat.type_diffuse.x - 1.0) <= EPSILON)
		{
			vec3 reflected_dir = reflect(ray.direction, data.normal);

			// Intersection point and new ray
			vec3 point = data.point;
			ray = Ray(point + EPSILON * data.normal, reflected_dir, 1.0 / reflected_dir);

			// If we sample uniformly or with cosine weighted sampling, then
			// we would need to calculate the BRDF every single direction in the
			// hemisphere. If the direction is the reflected direction, then
			// the BRDF is 1, otherwise it is 0. But that is wasteful. Instead,
			// we *only* pick the reflected direction (not the case for glossy or
			// otherwise un-ideal reflective materials) so the pdf is 1, and the
			// BRDF is 1. Because of this, we have an instant solution without
			// having to sample the hemisphere at all. The throughput term is then
			// BRDF*(Nx dot wi) = (Nx dot wi) = cos_theta_x
			throughput_term *= mat.specular_spec.xyz;
		}
		// if the material is a Phong material
		else if(abs(mat.type_diffuse.x - 3.0) <= EPSILON)
		{
			vec3 uvec = vec3(rand());

			vec3 diffuse = mat.type_diffuse.yzw;
			vec3 specular = mat.specular_spec.xyz;
			float spec = mat.specular_spec.w;
			vec3 pi_diffuse = PI * diffuse;

			if(all(lessThanEqual(uvec, pi_diffuse)))
			{
				throughput_term *= pi_diffuse;

				// pdf(psi) = cos(theta) / PI
				vec3 dir = map_to_unit_hemisphere_cosine_weighted_criver(rand_vec2(), data.normal);

				ray = Ray(data.point + EPSILON * data.normal, dir, 1.0 / dir);
			}
			else if(all(lessThanEqual(uvec, pi_diffuse + specular)))
			{
				vec3 x = data.point + EPSILON * data.normal;

				vec3 reflected_dir = normalize(reflect(ray.direction, data.normal));
				mat3 tnb = construct_tnb(reflected_dir);

				float inv = 1.0 / (spec + 1.0);

				vec2 rand_vec = rand_vec2();

				float cos_alpha = pow(rand_vec.x, inv);
				float sin_alpha = sqrt(1.0 - cos_alpha * cos_alpha);
				float phi = TWO_PI * rand_vec.y;

				vec3 dir = vec3(sin_alpha * cos(phi), cos_alpha, sin_alpha * sin(phi));

				dir = tnb * dir;
				ray = Ray(x, dir, 1.0 / dir);

				float cos_theta_x = max(0.0, dot(dir, data.normal));

				float pow_cosalpha_spec = pow(cos_alpha, spec);
				// float pdf_theta = ((spec + 1.0) / (2.0 * PI)) * pow(cos_alpha, spec);
				float pdf_theta = spec * HALF_PI * pow_cosalpha_spec + HALF_PI * pow_cosalpha_spec;
				// float theta_term = pow(cos_alpha, spec) * ((spec + 2.0) / (2.0 * PI)) / pdf_theta;
				float theta_term = pow_cosalpha_spec * spec * HALF_PI / pdf_theta + PI * pow_cosalpha_spec / pdf_theta;

				throughput_term *= specular * cos_theta_x * theta_term;
			}
		}
		else
			// UNSUPPORTED MATERIAL!
			return vec3(0.0, 0.0, 0.0);
	}

	return color;
}

vec3 render_function(uvec2 screen_size, ivec2 pixel_coords)
{
	uint width = screen_size.x;
	uint height = screen_size.y;
	float aspect_ratio = float(width) / height;

	float grid_height = 2.0;
	float grid_width = aspect_ratio * grid_height;

	vec3 grid_x = vec3(grid_width, 0.0, 0.0);
	vec3 grid_y = vec3(0.0, grid_height, 0.0);

	vec3 eye = vec3(0.0, 0.0, 0.0);
	vec3 grid_origin = eye - (grid_x * 0.5) - (grid_y * 0.5);
	grid_origin.z = -2.0;

	int x = pixel_coords.x;
	int y = pixel_coords.y;

	vec2 offset_to_pixel_center = vec2(0.5, 0.5);

	vec2 uv_offset = rand_vec2() - offset_to_pixel_center;

	float u = (float(x) + uv_offset.x) / float(width);
	float v = (float(y) + uv_offset.y) / float(height);

	vec3 point_on_grid = grid_origin + u * grid_x + v * grid_y;
	vec3 ray_direction = normalize(point_on_grid - eye);

	Ray ray = Ray(eye, ray_direction, 1.0 / ray_direction);

	return estimator_path_tracing_lambertian(ray);
}

void main() 
{
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	uvec2 screen_size = imageSize(screen);
	
	rng_state = seed3(uvec3(pixel_coords, u_seed));

	vec3 color = render_function(screen_size, pixel_coords);

	// weigh current frame according to accumulated past
	// frames and the current frame number
	vec4 last_frame = imageLoad(screen, pixel_coords);
	color = float(frame_count) / float(frame_count + 1) * last_frame.xyz + 1.0 / float(frame_count + 1) * color;

	imageStore(screen, pixel_coords, vec4(color, 1.0));
}